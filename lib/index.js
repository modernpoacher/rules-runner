"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=void 0;var _debug=_interopRequireDefault(require("debug"));var _objectPath=_interopRequireDefault(require("object-path"));var _common=require("./common");var comparators=_interopRequireWildcard(require("./comparators"));function _getRequireWildcardCache(){if(typeof WeakMap!=="function")return null;var cache=new WeakMap();_getRequireWildcardCache=function(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const log=(0,_debug.default)('@modernpoacher/rules-runner');log('`rules-runner` is awake');const hasArrayKey=key=>/^(.*)\[\]$/.test(key);function getArrayKey(key){const[,arrayKey]=key.match(/^(.*)\[\]$/);return arrayKey;}class RulesRunner{constructor(config){this.config=config;}run(values={},decisions={}){return Object.values(this.config).reduce((accumulator,rule)=>{if(Reflect.has(rule,'if')){const IF=Reflect.get(rule,'if');if(this.runTests(IF,values)){if(Reflect.has(rule,'then')){const THEN=Reflect.get(rule,'then');return this.runOutcomes(THEN,accumulator);}}else{if(Reflect.has(rule,'otherwise')){const OTHERWISE=Reflect.get(rule,'otherwise');return this.runOutcomes(OTHERWISE,accumulator);}}return accumulator;}throw new Error('A rule must have an `if` and a `then`');},decisions);}runTests(expectations={},values={}){return Object.entries(expectations).every(([key,expectation])=>{if(_objectPath.default.has(values,key)){const actual=_objectPath.default.get(values,key);return this.runTest(expectation,actual);}throw new Error(`Unknown path "${key}"`);});}runTest(expectation,...actual){if(expectation===null)throw new Error('Expectation is `null`');if(expectation===undefined)throw new Error('Expectation is `undefined`');if((0,_common.isObject)(expectation)){return Object.entries(expectation).some(([key,value])=>{if(Reflect.has(comparators,key)){const comparator=Reflect.get(comparators,key);return comparator.call(this,{[key]:value},...actual);}throw new Error(`Unknown comparator "${key}"`);});}if((0,_common.isBoolean)(expectation)){const{boolean}=comparators;return boolean.call(this,expectation,...actual);}const{equals}=comparators;return equals.call(this,expectation,...actual);}runOutcomes(outcomes={},accumulator={}){return Object.entries(outcomes).reduce((accumulator,[key,outcome])=>{if(hasArrayKey(key)){_objectPath.default.push(accumulator,getArrayKey(key),outcome);}else{_objectPath.default.set(accumulator,key,outcome);}return accumulator;},accumulator);}}exports.default=RulesRunner;